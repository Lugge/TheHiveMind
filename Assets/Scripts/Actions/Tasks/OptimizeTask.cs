//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.18444
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System.Collections;

namespace AntHill
{
	/*
	 * Custom Task to optimize a path to a food position.
	 * 
	 * @ToDo: Implement the functionality
	 * 
	 * @author: Lukas Krose
	 * @version: 1.0
	 */
	public class OptimizeTask : Task
	{

		/*
		 * Returns the type of the task
		 * 
		 * @return: string The type
		 * @author: Lukas Krose
		 * @version: 1.0
		 */

		public override string getType ()
		{
			return "OptimizeTask";
		}
		/*
		 * Initializes the task. Path is reset and the position of the ant hill is addeed as first entry to the path.
		 * 
		 * @ToDo: Reset the path to the path of a given food source
		 * 
		 * @param: Vector3 anthillPosition The Position of the ant hill
		 * @param: AntProperties prop The properties of the ant
		 * @author: Lukas Krose
		 * @since: 1.0
		 */
		public override void init(Vector3 anthillPosition, AntProperties properties){
			baseInit (anthillPosition, properties);
			path = new Path ();
			path.addMovement (anthillPosition);
			currentStepCount++;

			return;
		}

		/*
		 * Runs the task and returns the next position the ant should go to. 
		 * Optimizes the path to a given food source. For each step the ant tries to go directly to the food source. 
		 * If that is not possible it returns to the original path and tries to connect two Vectors by skipping the next Vector on the path.
		 * If that is not possible it continues to the next position on the path.
		 *
		 * @ToDo: Implement the functionality
		 *
		 * @return Vector3 The current step if the targtet has not been reached or the next best movement
		 * @author: Lukas Krose
		 * @since: 1.0
		 */
		public override Vector3 perform() {
			if (!hasReachedNextPosition ())return nextMovementTarget;
			return nextMovementTarget;
			/*
			Vector3 lastCoord = mem.currentTask.target;
			
			if(currentPosition == lastCoord){
				goHome();
				return;
			}
			
			Vector3 direction = currentPosition + lastCoord;
			Vector3 clampedDir = Vector3.ClampMagnitude(direction, maxTrvl);
			
			if (Util.isValid (clampedDir, currentPosition)) {
				nextMovementTarget = clampedDir;
				return;
			}
			
			nextMovementTarget = clampedDir;
			*/

		}

		/*
		 * Resets the task. 
		 * Clears the current and total step count and reinitializes itself.
		 * 
		 * @param: Vector3 anthillPosition The Position of the ant hill
		 * @author: Lukas Krose
		 * @since: 1.0
		 */
		public override void reset(Vector3 anthillPosition){
			currentStepCount = 0;
			stepCount = 0;
			path = new Path();
			init (anthillPosition, prop);
		}
		/*
		 * Resets the movement. 
		 * Currently just resets the task.
		 * 
		 * @param: Vector3 anthillPosition The Position of the ant hill
		 * @author: Lukas Krose
		 * @since: 1.0
		 */
		public override void supply(Vector3 anthillPosition){
			reset (anthillPosition);
		}
	}
}

