//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.18444
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System.Collections;

namespace AntHill
{
	/*
	 * Custom Task to optimize a path to a food position.
	 * 
	 * @ToDo: Implement the functionality
	 * 
	 * @author: Lukas Krose
	 * @version: 1.0
	 */
	public class OptimizeTask : Task
	{

		private Path optimizePath = new Path();
		private Path optimizeFin = new Path ();
		private bool debug = false;


		/*
		 * Returns the type of the task
		 * 
		 * @return: string The type
		 * @author: Lukas Krose
		 * @version: 1.0
		 */

		public override string getType ()
		{
			return "OptimizeTask";
		}
		/*
		 * Initializes the task. Path is reset and the position of the ant hill is addeed as first entry to the path.
		 * 
		 * @ToDo: Reset the path to the path of a given food source
		 * 
		 * @param: Vector3 anthillPosition The Position of the ant hill
		 * @param: AntProperties prop The properties of the ant
		 * @author: Lukas Krose
		 * @since: 1.0
		 */
		public override void init(Vector3 anthillPosition, AntProperties properties){
			baseInit (anthillPosition, properties);
			currentStepCount = 1;
			traveledPath = new Path ();
			traveledPath.addMovement (anthillPosition);
			optimizeFin = new Path ();
			optimizePath = new Path ();
			initialTarget = getTarget ();
			phase = 1;

			return;
		}

		/*
		 * Runs the task and returns the next position the ant should go to. 
		 * Optimizes the path to a given food source. For each step the ant tries to go directly to the food source. 
		 * If that is not possible it returns to the original path and tries to connect two Vectors by skipping the next Vector on the path.
		 * If that is not possible it continues to the next position on the path.
		 *
		 * @ToDo: Implement the functionality
		 *
		 * @return Vector3 The current step if the targtet has not been reached or the next best movement
		 * @author: Lukas Krose
		 * @since: 1.0
		 */
		public override Vector3 perform() {

			if(phase == 1){
				return phase1();
			}
			if(phase == 2){
				return phase2();
			}
			if(phase == 3){
				return phase3();
			}
			if(phase == 4){
				return phase4();
			}
			if(phase == 5){
				return phase5();
			}

			return phase6();
			
			/*
			Vector3 lastCoord = mem.currentTask.target;
			
			if(currentPosition == lastCoord){
				goHome();
				return;
			}
			
			Vector3 direction = currentPosition + lastCoord;
			Vector3 clampedDir = Vector3.ClampMagnitude(direction, maxTrvl);
			
			if (Util.isValid (clampedDir, currentPosition)) {
				nextMovementTarget = clampedDir;
				return;
			}
			
			nextMovementTarget = clampedDir;
			*/

		}

		public Vector3 phase1 () {
			if (debug) Debug.Log ("Start");
			System.Random rnd = new System.Random ();

			phase = 2;
			optimizeFin.addMovement (providedPath.getMovement (0));
			if(rnd.Next(1,10) <= 5){
				if (debug) Debug.Log("startAt0");
				return providedPath.getMovement(0);
			}
			return providedPath.getMovement (1);
		}

		public Vector3 phase2() {

			if (debug) Debug.Log ("Phase2");
			Vector3 currentStepObject = providedPath.getStepObject (currentPosition);
			int curIndex = providedPath.path.IndexOf (currentStepObject);
			if (curIndex == -1) {
				if (debug) Debug.Log("curPos: " + currentPosition);
				providedPath.debugPath();
				throw new UnityException("Error in phase 2. Can not find current position on Path.");
			}
			if (providedPath.path.IndexOf (initialTarget) == curIndex + 1) {
				if (debug)
					Debug.Log ("OneStepToGo");
				setTarget (providedPath.getMovement (curIndex + 1));
			} else if (providedPath.path.IndexOf (initialTarget) == curIndex) {
				goHome ();
				return phase6 ();
			} else {
				setTarget (providedPath.getMovement (curIndex + 2));
			}

			phase = 3;
			optimizePath = new Path ();
			if (debug) Debug.Log("To Optimize: " + getTarget());
			return phase3 ();
		}

		public Vector3 phase3() {
			if (debug) Debug.Log ("Phase3");
			try{
				moveDirection (getTarget());
				if (debug) Debug.Log ("Opt:" + nextMovementTarget);
			}
			catch(UnityException e){
				if (debug) Debug.Log(e);
				if(optimizePath.path.Count == 0){
					phase = 5;
					return phase5();
				} else{
					phase = 4;
					setTarget (optimizePath.getMovement(0));
					return phase4();
				}
			}

			optimizePath.addMovement (nextMovementTarget);

			if(nextMovementTarget == getTarget()){
				if (debug) Debug.Log("reachedStep");
				phase = 2;
				foreach(Vector3 v in optimizePath.path){
					optimizeFin.addMovement(v);
				}
			}

			if(nextMovementTarget == initialTarget) {
				goHome ();
				taskSuccessful = true;
				if (debug) Debug.Log("Success");
				traveledPath = new Path(optimizeFin);
			}


			return nextMovementTarget;
		}

		public Vector3 phase4() {
			if (debug) Debug.Log ("Phase4");
			if(hasReachedTarget()){
				phase = 5;
				return phase5 ();
			}
			return moveOnPath (finalTarget, optimizePath);
		}

		public Vector3 phase5() {
			if (debug) Debug.Log ("Phase5");
			Vector3 currentStepObject = providedPath.getStepObject (currentPosition);
			int curIndex = providedPath.path.IndexOf (currentStepObject);
			if(curIndex == -1){
				throw new UnityException("Error in phase 5. Can not find current position on Path.");
			}
			phase = 2;
			moveOnPath (providedPath.getMovement(curIndex + 1));
			optimizePath.addMovement (nextMovementTarget);
			return nextMovementTarget;
		}

		public Vector3 phase6() {
			if (debug) Debug.Log ("Phase6 " + finalTarget);
			return moveOnPath (finalTarget);
		}

		/*
		 * Resets the task. 
		 * Clears the current and total step count and reinitializes itself.
		 * 
		 * @param: Vector3 anthillPosition The Position of the ant hill
		 * @author: Lukas Krose
		 * @since: 1.0
		 */
		public override void reset(Vector3 anthillPosition){
			init (anthillPosition, prop);
		}
		/*
		 * Resets the movement. 
		 * Currently just resets the task.
		 * 
		 * @param: Vector3 anthillPosition The Position of the ant hill
		 * @author: Lukas Krose
		 * @since: 1.0
		 */
		public override void supply(Vector3 anthillPosition){
			//reset (anthillPosition);
			return;
		}

		public override void goHome() {
			if (debug) Debug.Log ("Head home");
			phase = 6;
			taskFinished = true;
			finalTarget = traveledPath.getMovement (0);
		}
	}
}

